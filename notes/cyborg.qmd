# CybORG

Some relevant points to extract the graph structure implicitly defined in CybORG.

## Layout of the network

Possible connections are defined in the scenario configuration file `Scenario2.yaml` under the `info` entry per host.

```python
# self = State()
>>> pprint({host: self.hosts[host].info for host in scenario.hosts})
{
│   'Defender': {},
│   'Enterprise0': {'Enterprise0': {'Interfaces': 'All'}},
│   'Enterprise1': {'Enterprise1': {'Interfaces': 'All'}},
│   'Enterprise2': {'Enterprise2': {'Interfaces': 'All'}, 'Op_Server0': {'Interfaces': 'IP Address'}},
│   'Op_Host0': {'Op_Host0': {'Interfaces': 'All'}},
│   'Op_Host1': {'Op_Host1': {'Interfaces': 'All'}},
│   'Op_Host2': {'Op_Host2': {'Interfaces': 'All'}},
│   'Op_Server0': {'Op_Server0': {'Interfaces': 'All', 'Services': ['OTService']}},
│   'User0': {'User0': {'Interfaces': 'All'}},
│   'User1': {'Enterprise1': {'Interfaces': 'IP Address'}, 'User1': {'Interfaces': 'All'}},
│   'User2': {'Enterprise1': {'Interfaces': 'IP Address'}, 'User2': {'Interfaces': 'All'}},
│   'User3': {'Enterprise0': {'Interfaces': 'IP Address'}, 'User3': {'Interfaces': 'All'}},
│   'User4': {'Enterprise0': {'Interfaces': 'IP Address'}, 'User4': {'Interfaces': 'All'}}
}
```

:::{.callout-note}
- If a self interface is defined, that host is reachable by the red agent.
- Assume all communication between hosts in the same subnet is possible.
- Communication between hosts in different subnets is only possible if interfaces define it.
:::

:::{.callout-warning}
- Are the NACLs really used at all?
:::

<!-- TODO  explain how low level observability relates to blue table observation and prev gym observation -->

## Action space

```python
>>> action_space = cyborg.environment_controller.agent_interfaces["Blue"].action_space
>>> action_space.action_params  # dict with signature of each actions
# ...
>>> action_space.get_action_space()
# {
#     'action': self.actions,
#     'subnet': self.subnet,
#     'ip_address': self.ip_address,
#     'session': self.server_session,
#     'username': self.username,
#     'password': self.password,
#     'process': self.process,
#     'port': self.port,
#     'target_session': self.client_session,
#     'agent': self.agent,
#     'hostname': self.hostname
# }
>>> action_space.get_max_actions(action)
# def get_max_actions(self, action):
#     params = self.action_params[action]
#     size = 1
#     for param in params.keys():
#         if param == "session":
#             size *= len(self.server_session)
#         elif param == "target_session":
#             size *= len(self.client_session)
#         elif param == "subnet":
#             size *= len(self.subnet)
#         elif param == "ip_address":
#             size *= len(self.ip_address)
#         elif param == "username":
#             size *= len(self.username)
#         elif param == "password":
#             size *= len(self.password)
#         elif param == "process":
#             size *= len(self.process)
#         elif param == "port":
#             size *= len(self.port)
#         elif param == "agent":
#             size *= len(self.agent)
#         else:
#             raise NotImplementedError(
#                 f"Param '{param}' in action '{action.__name__}' has no"
#                 " code to parse its size for action space"
#             )
#     return size
```
